{"version":3,"file":"332.dist-bundle.js","mappings":"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","sources":["webpack://website/./node_modules/@atlaskit/media-ui/dist/esm/humanReadableSize.js","webpack://website/./node_modules/@atlaskit/media-ui/dist/esm/imageMetaData/types.js","webpack://website/./node_modules/@atlaskit/media-ui/dist/esm/imageMetaData/parseJPEG.js","webpack://website/./node_modules/@atlaskit/media-ui/dist/esm/imageMetaData/parsePNG.js","webpack://website/./node_modules/@atlaskit/media-ui/dist/esm/imageMetaData/parsePNGXMP.js","webpack://website/./node_modules/@atlaskit/media-ui/dist/esm/imageMetaData/metatags.js","webpack://website/./node_modules/@atlaskit/media-ui/dist/esm/imageMetaData/index.js","webpack://website/./node_modules/@atlaskit/media-ui/dist/esm/mime-type-icon.js","webpack://website/./node_modules/@atlaskit/media-ui/node_modules/bytes/index.js"],"sourcesContent":["import * as bytes from 'bytes'; // eslint-disable-next-line no-bitwise\n\nvar ONE_MEGABYTE_IN_BYTES = 1 << 20;\n/**\n * Takes a media (file) size in bytes and returns a human readable string\n */\n\nexport function toHumanReadableMediaSize(size) {\n  // [MS-967]: Api issue might return string for size\n  var parsedSize = parseInt(\"\".concat(size), 10);\n  var decimalPlaces = parsedSize < ONE_MEGABYTE_IN_BYTES ? 0 : 1;\n  return bytes.format(parsedSize, {\n    unitSeparator: ' ',\n    decimalPlaces: decimalPlaces\n  }).toUpperCase();\n}","export var ImageType;\n\n(function (ImageType) {\n  ImageType[\"JPEG\"] = \"image/jpeg\";\n  ImageType[\"PNG\"] = \"image/png\";\n})(ImageType || (ImageType = {}));\n\nexport var SupportedImageMetaTag;\n\n(function (SupportedImageMetaTag) {\n  SupportedImageMetaTag[\"XResolution\"] = \"XResolution\";\n  SupportedImageMetaTag[\"YResolution\"] = \"YResolution\";\n  SupportedImageMetaTag[\"Orientation\"] = \"Orientation\";\n})(SupportedImageMetaTag || (SupportedImageMetaTag = {}));\n\n// http://sylvana.net/jpegcrop/exif_orientation.html\nexport var ExifOrientation = {\n  'top-left': 1,\n  // none\n  'top-right': 2,\n  // flip horizontal\n  'bottom-right': 3,\n  // rotate 180\n  'bottom-left': 4,\n  // flip vertical\n  'left-top': 5,\n  // transpose\n  'right-top': 6,\n  // rotate 90\n  'right-bottom': 7,\n  // transverse\n  'left-bottom': 8 // rotate 270\n\n};","import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { SupportedImageMetaTag } from './types';\nvar XResolution = SupportedImageMetaTag.XResolution,\n    YResolution = SupportedImageMetaTag.YResolution;\nvar loadImage;\nexport function readJPEGExifMetaData(file) {\n  return new Promise( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {\n      var module;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (loadImage) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 3;\n              return import('blueimp-load-image');\n\n            case 3:\n              module = _context.sent;\n              loadImage = module.default || module;\n\n            case 5:\n              loadImage.parseMetaData(file, function (data) {\n                try {\n                  var tags = data && data.exif ? data.exif.getAll() : {};\n                  Object.keys(tags).forEach(function (key) {\n                    var value = tags[key];\n\n                    if (_typeof(value) === 'object' && (key === XResolution || key === YResolution) && 'numerator' in value) {\n                      // some test images had this structure, so just take the numerator value to simplify returned value\n                      tags[key] = value.numerator;\n                    }\n\n                    if (typeof tags[key] === 'number') {\n                      // in case numbers types were auto-converted, keep everything the same between jpeg & png we keep as strings\n                      tags[key] = \"\".concat(tags[key]);\n                    }\n                  });\n                  resolve(tags);\n                } catch (e) {\n                  reject(e);\n                }\n              });\n\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n}","import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { fileToArrayBuffer } from '../util';\nvar pngChunksExtract;\nexport function readPNGXMPMetaData(_x) {\n  return _readPNGXMPMetaData.apply(this, arguments);\n}\n\nfunction _readPNGXMPMetaData() {\n  _readPNGXMPMetaData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(file) {\n    var module, buffer, chunks;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (pngChunksExtract) {\n              _context.next = 5;\n              break;\n            }\n\n            _context.next = 3;\n            return import('png-chunks-extract');\n\n          case 3:\n            module = _context.sent;\n            pngChunksExtract = module.default || module;\n\n          case 5:\n            _context.next = 7;\n            return fileToArrayBuffer(file);\n\n          case 7:\n            buffer = _context.sent;\n            chunks = pngChunksExtract(buffer);\n            _context.next = 11;\n            return parsePNGChunks(chunks);\n\n          case 11:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _readPNGXMPMetaData.apply(this, arguments);\n}\n\nexport function parsePNGChunks(_x2) {\n  return _parsePNGChunks.apply(this, arguments);\n}\n\nfunction _parsePNGChunks() {\n  _parsePNGChunks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(chunks) {\n    var iTXt, pHYs, i, chunk, dv, unitSpecifier, PixelPerUnitX, PixelPerUnitY;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            iTXt = '';\n            pHYs = {};\n            /**\n             * http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.Summary-of-standard-chunks\n             * Order of every chunk is not guaranteed.\n             * And both iTXt and pHYs are Ancillary chunks.\n             */\n\n            i = 0;\n\n          case 3:\n            if (!(i < chunks.length)) {\n              _context2.next = 12;\n              break;\n            }\n\n            chunk = chunks[i]; // Must be last\n\n            if (!(chunk.name === 'IEND')) {\n              _context2.next = 7;\n              break;\n            }\n\n            return _context2.abrupt(\"break\", 12);\n\n          case 7:\n            /**\n             * http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.Anc-text\n             * iTXt contains the useful XMP/XML string data of meta tags\n             */\n            if (chunk.name === 'iTXt') {\n              iTXt = String.fromCharCode.apply(null, Array.from(chunk.data));\n            }\n            /**\n             * http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.pHYs\n             * Pixels per unit, X axis: 4 bytes (unsigned integer)\n             * Pixels per unit, Y axis: 4 bytes (unsigned integer)\n             * Unit specifier:          1 byte  (0: unit is unknown 1: unit is the meter)\n             */\n\n\n            if (chunk.name === 'pHYs') {\n              dv = new DataView(chunk.data.buffer);\n              unitSpecifier = dv.getUint8(8); // meter\n\n              if (unitSpecifier === 1) {\n                PixelPerUnitX = dv.getUint32(0);\n                PixelPerUnitY = dv.getUint32(4);\n                pHYs = {\n                  PixelPerUnitX: PixelPerUnitX,\n                  PixelPerUnitY: PixelPerUnitY\n                };\n              }\n            }\n\n          case 9:\n            ++i;\n            _context2.next = 3;\n            break;\n\n          case 12:\n            return _context2.abrupt(\"return\", {\n              iTXt: iTXt,\n              pHYs: pHYs\n            });\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _parsePNGChunks.apply(this, arguments);\n}","export function parseXMPMetaData(xmpMetaData) {\n  var metadata = {};\n  var tags = xmpMetaData.match(/<(tiff|exif):.+>/gi);\n\n  if (tags) {\n    tags.forEach(function (tag) {\n      var match = tag.match(/<(tiff|exif):([^>]+)>([^<]+)/i);\n\n      if (match) {\n        var name = match[2];\n        metadata[name] = match[3];\n      }\n    });\n  }\n\n  return metadata;\n}","import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { ImageType } from './types';\nimport { readJPEGExifMetaData } from './parseJPEG';\nimport { readPNGXMPMetaData } from './parsePNG';\nimport { parseXMPMetaData } from './parsePNGXMP';\nexport function readImageMetaTags(_x) {\n  return _readImageMetaTags.apply(this, arguments);\n}\n\nfunction _readImageMetaTags() {\n  _readImageMetaTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(file) {\n    var type, _yield$readPNGXMPMeta, iTXt, pHYs, xmpMetaData;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            type = file.type;\n            _context.prev = 1;\n\n            if (!(type === ImageType.PNG)) {\n              _context.next = 12;\n              break;\n            }\n\n            _context.next = 5;\n            return readPNGXMPMetaData(file);\n\n          case 5:\n            _yield$readPNGXMPMeta = _context.sent;\n            iTXt = _yield$readPNGXMPMeta.iTXt;\n            pHYs = _yield$readPNGXMPMeta.pHYs;\n            xmpMetaData = _objectSpread(_objectSpread({}, parseXMPMetaData(iTXt)), pHYs);\n            return _context.abrupt(\"return\", xmpMetaData);\n\n          case 12:\n            if (!(file.type === ImageType.JPEG)) {\n              _context.next = 16;\n              break;\n            }\n\n            _context.next = 15;\n            return readJPEGExifMetaData(file);\n\n          case 15:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 16:\n            _context.next = 20;\n            break;\n\n          case 18:\n            _context.prev = 18;\n            _context.t0 = _context[\"catch\"](1);\n\n          case 20:\n            return _context.abrupt(\"return\", null);\n\n          case 21:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 18]]);\n  }));\n  return _readImageMetaTags.apply(this, arguments);\n}","import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { SupportedImageMetaTag, ExifOrientation } from './types';\nimport { readImageMetaTags } from './metatags';\nimport { loadImage, readImageNaturalOrientationFromDOM } from '../util';\nimport { isRotated } from './imageOrientationUtil';\nvar Orientation = SupportedImageMetaTag.Orientation,\n    XResolution = SupportedImageMetaTag.XResolution; // http://bonfx.com/why-is-the-web-72-dpi-and-print-300-dpi/\n\nvar DPI_WEB_BASELINE = 72;\nexport { ExifOrientation } from './types';\nexport function getImageInfo(_x) {\n  return _getImageInfo.apply(this, arguments);\n}\n\nfunction _getImageInfo() {\n  _getImageInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fileInfo) {\n    var metadata, width, height, tags, scaleFactor;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return readImageMetaData(fileInfo);\n\n          case 2:\n            metadata = _context.sent;\n\n            if (metadata) {\n              _context.next = 5;\n              break;\n            }\n\n            return _context.abrupt(\"return\", null);\n\n          case 5:\n            width = metadata.width, height = metadata.height, tags = metadata.tags;\n            scaleFactor = getScaleFactor(fileInfo.file, tags);\n            return _context.abrupt(\"return\", {\n              scaleFactor: scaleFactor,\n              width: width,\n              height: height\n            });\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getImageInfo.apply(this, arguments);\n}\n\nexport function getScaleFactor(file, tags) {\n  var scaleFactorFromFilename = getScaleFactorFromFile(file);\n\n  if (scaleFactorFromFilename !== null) {\n    return scaleFactorFromFilename;\n  } else if (tags) {\n    /**\n     * Scale Factor is actually a 2D thing, but in practice X & Y are same in 99% cases.\n     * So we are only relying on X axis.\n     */\n    if (typeof tags['PixelPerUnitX'] === 'number') {\n      // 1 inch = 0.0254 meters\n      return Math.round(tags['PixelPerUnitX'] * 0.0254) / DPI_WEB_BASELINE;\n    } else {\n      return getMetaTagNumericValue(tags, XResolution, DPI_WEB_BASELINE) / DPI_WEB_BASELINE;\n    }\n  } else {\n    return 1;\n  }\n}\n\nvar getOrientationFromTags = function getOrientationFromTags(tags) {\n  if (tags && tags[Orientation]) {\n    var tagValue = tags[Orientation];\n\n    if (tagValue) {\n      var numericValue = parseInt(tagValue, 10);\n\n      if (isNaN(numericValue)) {\n        return ExifOrientation[tagValue];\n      }\n\n      return numericValue;\n    }\n  }\n\n  return 1;\n};\n\nexport function getOrientation(_x2) {\n  return _getOrientation.apply(this, arguments);\n}\n\nfunction _getOrientation() {\n  _getOrientation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(file) {\n    var tags;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return readImageMetaTags(file);\n\n          case 2:\n            tags = _context2.sent;\n            return _context2.abrupt(\"return\", getOrientationFromTags(tags));\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getOrientation.apply(this, arguments);\n}\n\nexport function getMetaTagNumericValue(tags, key, defaultValue) {\n  try {\n    var num = parseFloat(\"\".concat(tags[key]));\n\n    if (!isNaN(num)) {\n      return num;\n    }\n  } catch (e) {//\n  }\n\n  return defaultValue;\n}\nexport function getScaleFactorFromFile(file) {\n  try {\n    // filenames with scale ratio in name take precedence - eg. filename@2x.png\n    var match = file.name.trim().match(/@([0-9\\.]+)x\\.[a-z]{3}$/);\n\n    if (match) {\n      return parseFloat(match[1]);\n    }\n  } catch (e) {// parse problem, return null\n  }\n\n  return null;\n}\nexport function readImageMetaData(_x3) {\n  return _readImageMetaData.apply(this, arguments);\n}\n\nfunction _readImageMetaData() {\n  _readImageMetaData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(fileInfo) {\n    var file, src, type, width, height, tags, orientation, isImageRotated, data, img, _readImageNaturalOrie, _width, _height;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            file = fileInfo.file, src = fileInfo.src;\n            type = file.type;\n            width = 0;\n            height = 0;\n            _context3.next = 6;\n            return readImageMetaTags(file);\n\n          case 6:\n            tags = _context3.sent;\n\n            // since we're reading metadata anyway, try to get dimensions from there...\n            if (tags && tags.PixelXDimension) {\n              width = getMetaTagNumericValue(tags, 'PixelXDimension', 0);\n            }\n\n            if (tags && tags.PixelXDimension) {\n              height = getMetaTagNumericValue(tags, 'PixelYDimension', 0);\n            } // otherwise, load the image async (ideally avoid if found above due to being slightly expensive)\n\n\n            orientation = getOrientationFromTags(tags);\n            isImageRotated = isRotated(orientation);\n            data = {\n              type: type,\n              width: width,\n              height: height,\n              naturalWidth: width,\n              naturalHeight: height,\n              tags: tags\n            };\n\n            if (!(isImageRotated || width === 0 && height === 0)) {\n              _context3.next = 27;\n              break;\n            }\n\n            _context3.prev = 13;\n            _context3.next = 16;\n            return loadImage(src);\n\n          case 16:\n            img = _context3.sent;\n            _readImageNaturalOrie = readImageNaturalOrientationFromDOM(img), _width = _readImageNaturalOrie.width, _height = _readImageNaturalOrie.height;\n            data.width = _width;\n            data.height = _height;\n            data.naturalWidth = img.naturalWidth;\n            data.naturalHeight = img.naturalHeight;\n            _context3.next = 27;\n            break;\n\n          case 24:\n            _context3.prev = 24;\n            _context3.t0 = _context3[\"catch\"](13);\n            return _context3.abrupt(\"return\", null);\n\n          case 27:\n            return _context3.abrupt(\"return\", data);\n\n          case 28:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[13, 24]]);\n  }));\n  return _readImageMetaData.apply(this, arguments);\n}\n\nexport { getCssFromImageOrientation, isRotated } from './imageOrientationUtil';","import React from 'react';\nimport { getMimeIcon } from './util';\nimport { MediaTypeIcon } from './media-type-icon';\nimport { IconWrapper } from './media-type-icon';\n\n/*\n * Renders an icon. First, check if the mimeType corresponds to any of the special mimeType icons (.gif, .sketch, .exe, ect). If so, render that icon.\n * Else, render an icon corresponding to its mediaType (doc/audio/image/video/unknown)\n */\nexport var MimeTypeIcon = function MimeTypeIcon(_ref) {\n  var _ref$mediaType = _ref.mediaType,\n      mediaType = _ref$mediaType === void 0 ? 'unknown' : _ref$mediaType,\n      _ref$mimeType = _ref.mimeType,\n      mimeType = _ref$mimeType === void 0 ? 'unknown' : _ref$mimeType,\n      _ref$name = _ref.name,\n      name = _ref$name === void 0 ? 'unknown' : _ref$name,\n      testId = _ref.testId;\n  // retrieve mimetype icon and label\n  var iconInfo = getMimeIcon(mimeType, name); // a corresponding mimetype icon and label was found.\n\n  if (iconInfo) {\n    var Icon = iconInfo.icon;\n    return /*#__PURE__*/React.createElement(IconWrapper, {\n      \"data-testid\": testId,\n      \"data-type\": iconInfo.label,\n      size: 'large'\n    }, /*#__PURE__*/React.createElement(Icon, {\n      label: iconInfo.label\n    }));\n  } // no correponding mimetype icon/label was found.\n  // Hence, return a mediatype (image/doc/audio/video/unknown) icon\n\n\n  return /*#__PURE__*/React.createElement(MediaTypeIcon, {\n    testId: testId,\n    type: mediaType,\n    size: 'large'\n  });\n};","/*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = bytes;\nmodule.exports.format = format;\nmodule.exports.parse = parse;\n\n/**\n * Module variables.\n * @private\n */\n\nvar formatThousandsRegExp = /\\B(?=(\\d{3})+(?!\\d))/g;\n\nvar formatDecimalsRegExp = /(?:\\.0*|(\\.[^0]+)0+)$/;\n\nvar map = {\n  b:  1,\n  kb: 1 << 10,\n  mb: 1 << 20,\n  gb: 1 << 30,\n  tb: ((1 << 30) * 1024)\n};\n\n// TODO: use is-finite module?\nvar numberIsFinite = Number.isFinite || function (v) { return typeof v === 'number' && isFinite(v); };\n\nvar parseRegExp = /^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb)$/i;\n\n/**\n * Convert the given value in bytes into a string or parse to string to an integer in bytes.\n *\n * @param {string|number} value\n * @param {{\n *  case: [string],\n *  decimalPlaces: [number]\n *  fixedDecimals: [boolean]\n *  thousandsSeparator: [string]\n *  unitSeparator: [string]\n *  }} [options] bytes options.\n *\n * @returns {string|number|null}\n */\n\nfunction bytes(value, options) {\n  if (typeof value === 'string') {\n    return parse(value);\n  }\n\n  if (typeof value === 'number') {\n    return format(value, options);\n  }\n\n  return null;\n}\n\n/**\n * Format the given value in bytes into a string.\n *\n * If the value is negative, it is kept as such. If it is a float,\n * it is rounded.\n *\n * @param {number} value\n * @param {object} [options]\n * @param {number} [options.decimalPlaces=2]\n * @param {number} [options.fixedDecimals=false]\n * @param {string} [options.thousandsSeparator=]\n * @param {string} [options.unit=]\n * @param {string} [options.unitSeparator=]\n *\n * @returns {string|null}\n * @public\n */\n\nfunction format(value, options) {\n  if (!numberIsFinite(value)) {\n    return null;\n  }\n\n  var mag = Math.abs(value);\n  var thousandsSeparator = (options && options.thousandsSeparator) || '';\n  var unitSeparator = (options && options.unitSeparator) || '';\n  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;\n  var fixedDecimals = Boolean(options && options.fixedDecimals);\n  var unit = (options && options.unit) || '';\n\n  if (!unit || !map[unit.toLowerCase()]) {\n    if (mag >= map.tb) {\n      unit = 'TB';\n    } else if (mag >= map.gb) {\n      unit = 'GB';\n    } else if (mag >= map.mb) {\n      unit = 'MB';\n    } else if (mag >= map.kb) {\n      unit = 'kB';\n    } else {\n      unit = 'B';\n    }\n  }\n\n  var val = value / map[unit.toLowerCase()];\n  var str = val.toFixed(decimalPlaces);\n\n  if (!fixedDecimals) {\n    str = str.replace(formatDecimalsRegExp, '$1');\n  }\n\n  if (thousandsSeparator) {\n    str = str.replace(formatThousandsRegExp, thousandsSeparator);\n  }\n\n  return str + unitSeparator + unit;\n}\n\n/**\n * Parse the string value into an integer in bytes.\n *\n * If no unit is given, it is assumed the value is in bytes.\n *\n * @param {number|string} val\n *\n * @returns {number|null}\n * @public\n */\n\nfunction parse(val) {\n  if (typeof val === 'number' && !isNaN(val)) {\n    return val;\n  }\n\n  if (typeof val !== 'string') {\n    return null;\n  }\n\n  // Test if the string passed is valid\n  var results = parseRegExp.exec(val);\n  var floatValue;\n  var unit = 'b';\n\n  if (!results) {\n    // Nothing could be extracted from the given string\n    floatValue = parseInt(val, 10);\n    unit = 'b'\n  } else {\n    // Retrieve the value and the unit\n    floatValue = parseFloat(results[1]);\n    unit = results[4].toLowerCase();\n  }\n\n  return Math.floor(map[unit] * floatValue);\n}\n"],"names":["toHumanReadableMediaSize","size","parsedSize","parseInt","concat","decimalPlaces","unitSeparator","toUpperCase","ImageType","SupportedImageMetaTag","ExifOrientation","XResolution","YResolution","readJPEGExifMetaData","file","Promise","_ref","_callee","resolve","reject","module","_context","prev","next","sent","default","parseMetaData","data","tags","exif","getAll","Object","keys","forEach","key","value","numerator","e","stop","_x","_x2","apply","this","arguments","pngChunksExtract","readPNGXMPMetaData","_readPNGXMPMetaData","buffer","chunks","parsePNGChunks","abrupt","_parsePNGChunks","_callee2","iTXt","pHYs","i","chunk","dv","PixelPerUnitX","PixelPerUnitY","_context2","length","name","String","fromCharCode","Array","from","DataView","getUint8","getUint32","parseXMPMetaData","xmpMetaData","metadata","match","tag","ownKeys","object","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","_objectSpread","target","source","getOwnPropertyDescriptors","defineProperties","defineProperty","_readImageMetaTags","type","_yield$readPNGXMPMeta","PNG","JPEG","t0","Orientation","getOrientationFromTags","tagValue","numericValue","isNaN","getOrientation","_getOrientation","MimeTypeIcon","_ref$mediaType","mediaType","_ref$mimeType","mimeType","_ref$name","testId","iconInfo","Icon","icon","label","exports","options","parse","format","formatThousandsRegExp","formatDecimalsRegExp","map","b","kb","mb","gb","tb","numberIsFinite","Number","isFinite","v","parseRegExp","mag","Math","abs","thousandsSeparator","undefined","fixedDecimals","Boolean","unit","toLowerCase","str","toFixed","replace","val","floatValue","results","exec","parseFloat","floor"],"sourceRoot":""}